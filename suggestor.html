
<!--
	should abort already running xmlhttprequest when typing along
	should cache the result (key in cache is the search value)
	should have zero delay
	should present suggestions as an unordered list
	should reuse the xmlhttprequest object and abort the previous one, if any
	should create the suggestions element dynamically
	should insert UL element dynamically, just after the text field
	should use DOM operations instead of innerHTML when updating
	
	should be OO
	should accept a function which retrives data and returns a filtered array of search result

	probably should use addClass instead of styling directly

	TODO:
	respond to arrow up and down when suggestions are shown DONE
	add key down event handler to search field DONE
	implement some way of keeping track of which element is selected DONE
	handle esc key DONE
	empty field yields weird results right now 
		solution is: not check if search field is empty, do something else. need to investigate
	programmatically highlight element under mouse cursor, instead of :hover. needed cuz it should
		seemlessly cooperate with key up and key down selections
-->

<!DOCTYPE html>
<html>
<head>
	<title>box</title>
	<link rel="stylesheet" type="text/css" href="suggestor.css">
	<script type="text/javascript">
		function $(id) {
			return document.getElementById(id);
		}

		var xmlhttp = new XMLHttpRequest();
		var url = "test.json";
		var selected, search_old;

		xmlhttp.onreadystatechange = function() {
			// console.log(this.readyState, this.status);
			if (this.readyState == 4 && this.status == 200) {
				var data = JSON.parse(this.responseText);

				$suggestions = $("suggestions");

				// remove all items from list
				while ($suggestions.firstChild) {
					$suggestions.removeChild($suggestions.firstChild);
				}

				// new regexp object, fetch search criteria from search box
				const regex = new RegExp("^" + $("search").value, 'i');
				data.forEach(item => {
					if (regex.test(item.name)) {
						$li = document.createElement("li");
						$text = document.createTextNode(item.name);

						$li.appendChild($text);
						$suggestions.appendChild($li);
					}
				});

				$("suggestions").style.display = 'block'; // <-- old skool (pre-html5) way of doing it
			}
		};
		
	</script>
</head>
<body>
	<div id="huba">
		<form>
			<input type="text" id="search" autocomplete="off" autofocus>
			<ul id="suggestions"></ul>
		</form>
	</div>
	<script type="text/javascript">
		$("suggestions").style.width = $("search").offsetWidth + 'px';
		$("search").addEventListener('input', e => {
			search_old = null; // reset
			selected = null;

			if ($("search").value !== '') {
				xmlhttp.open("GET", url, true);
				xmlhttp.send();
			}
			else $("suggestions").style.display = 'none';
		});
		$("search").addEventListener('blur', e => {
			$("suggestions").style.display = 'none';
		});
		$("search").addEventListener('keydown', e => {
			// if no suggestions, simply return here. prevents nested if-hell
			if (e.keyCode === 38 || e.keyCode === 40) { // TODO: check something else than value of search field
				e.preventDefault();

				if ($("suggestions").firstChild) { // does any suggestions exist ?
					switch (e.keyCode) {
						case 40: // arrow down
						if (selected) {
							selected.classList.remove('selected');
							selected = selected.nextSibling;
						}
						selected = selected || $("suggestions").firstChild;
						break;

						case 38: // arrow up
						if (selected) {
							selected.classList.remove('selected');
							selected = selected.previousSibling;
						}
						selected = selected || $("suggestions").lastChild;
					}

					selected.classList.add('selected');

					// store old value, for use when esc key is hit
					search_old = search_old || $("search").value;

					$("search").value = selected.textContent;
				}
			}
			else if (e.keyCode === 27) { // ESC key
				if (selected) $("search").value = search_old;
				$("suggestions").style.display = 'none';
			}
		});

		$("suggestions").addEventListener('mousedown', e => {
			$("search").value = e.srcElement.textContent;
			e.preventDefault(); // prevents the blur event from firing

			$("suggestions").style.display = 'none';
			selected = null;
			// .form is null if no parent form. if any parent form, .form holds a reference to it
			// if ($("search").form) $("search").form.submit();
		});
	</script>
</body>
</html>