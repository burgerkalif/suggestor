
<!--
	should abort already running xmlhttprequest when typing along
	should cache the result (key in cache is the search value)
	should have zero delay
	should present suggestions as an unordered list
	should reuse the xmlhttprequest object and abort the previous one, if any
	should create the suggestions element dynamically
	should insert UL element dynamically, just after the text field
	should use DOM operations instead of innerHTML when updating
	should show suggestions in a box with a max-height, overflow will cause scrollbar
	should handle key down and key up accordingly (scroll selected item into view)

	should be OO
	should accept a function which retrives data and returns a filtered array of search result

	TODO:
	should abort ajax request when ESC key is pressed
	should accept path in data source (JSON) as a string
		ie: "name" => item.name & "name.first" ) => item.name.first
-->

<!DOCTYPE html>
<html>
<head>
	<title>box</title>
	<link rel="stylesheet" type="text/css" href="suggestor.css">
	<script type="text/javascript">
		const key = {
			up: 38,
			down: 40,
			esc: 27
		}

		function $(id) {
			return document.getElementById(id);
		}

		function hide() {
			$("suggestions").style.display = 'none';
			visible = false;
			selected = null;
		}

		function show() {
			$("suggestions").style.display = 'block';
			visible = true;	
		}

		var xmlhttp = new XMLHttpRequest();
		var url = "test.json";
		var selected, search_old, visible;

		xmlhttp.onreadystatechange = function() {
			var q = $("search").value.trimLeft();

			if (q.length && this.readyState == 4 && this.status == 200) {
				var data = JSON.parse(this.responseText);
				var $suggestions = $("suggestions");

				// remove all items from list
				while ($suggestions.firstChild) {
					$suggestions.removeChild($suggestions.firstChild);
				}

				// escape special characters (anything non-alphanumeric + space)
				q = q.replace(/([^a-z0-9_ ])/gi, '\\$1');

				// new regexp object
				const regex = new RegExp("(" + q + ")", 'gi');
				data.forEach(item => {
					if (regex.test(item.name)) {
						var $li = document.createElement("li");
						$li.innerHTML = item.name.replace(regex, '<b>$1</b>');
						$suggestions.appendChild($li);
					}
				});

				// show only if list of suggestions isn't empty
				if ($suggestions.firstChild) show();
			}
		};
		
	</script>
</head>
<body>
	<div id="huba">
		<form>
			<input type="text" id="search" autocomplete="off" autofocus>
			<ul id="suggestions"></ul>
		</form>
	</div>
	<script type="text/javascript">
		$("suggestions").style.width = $("search").offsetWidth + 'px';
		$("search").addEventListener('input', e => {
			search_old = null; // reset
			selected = null;
			visible = false;

			if ($("search").value.trimLeft().length) {
				xmlhttp.open("GET", url + '?' + Date.now().toString(), true);
				xmlhttp.send();
			}
			else hide();
		});
		$("search").addEventListener('blur', e => {
			hide();
		});
		$("search").addEventListener('keydown', e => {
			if (e.keyCode === key.esc) { // ESC key

				// abort pending ajax request, if any
				if (xmlhttp.readyState > 0 && xmlhttp.readyState < 4) xmlhttp.abort();
				if (selected) {
					$("search").value = search_old;
					hide();
				}
				else {
					$("search").value = '';
					if (visible) hide();
				}
			}

			// only handle arrow up & down if any suggestions
			else if (~[key.up, key.down].indexOf(e.keyCode) && visible) {
				e.preventDefault();

				switch (e.keyCode) {
					case key.down:
					if (selected) {
						selected.classList.remove('selected');
						selected = selected.nextSibling;
					}
					else selected = $("suggestions").firstChild;
					break;

					case key.up:
					if (selected) {
						selected.classList.remove('selected');
						selected = selected.previousSibling;
					}
					else selected = $("suggestions").lastChild;
				}

				if (selected) selected.classList.add('selected');

				// store old value
				search_old = search_old || $("search").value;
				$("search").value = (selected) ? selected.textContent : search_old;
			}
		});

		$("suggestions").addEventListener('mousedown', e => {
			$("search").value = e.target.textContent;
			e.preventDefault(); // prevents the blur event from firing

			hide();
		});
	</script>
</body>
</html>