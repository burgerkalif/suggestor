
<!--
	should abort already running xmlhttprequest when typing along
	should cache the result (key in cache is the search value)
	should have zero delay
	should present suggestions as an unordered list
	should reuse the xmlhttprequest object and abort the previous one, if any
	should create the suggestions element dynamically
	should insert UL element dynamically, just after the text field
	should use DOM operations instead of innerHTML when updating
	should show suggestions in a box with a max-height, overflow will cause scrollbar
	should handle key down and key up accordingly (scroll selected item into view)

	should be OO
	should accept a function which retrives data and returns a filtered array of search result

	TODO:
	should accept path in data source (JSON) as a string
		ie: "name" => item.name & "name.first" ) => item.name.first
-->

<!DOCTYPE html>
<html>
<head>
	<title>box</title>
	<link rel="stylesheet" type="text/css" href="suggestor.css">
	<script type="text/javascript">
		const key = {
			up: 38,
			down: 40,
			esc: 27
		}

		function $(id) {
			return document.getElementById(id);
		}

		function hide() {
			$("suggestions").style.display = 'none';
			visible = false;
		}

		function show() {
			$("suggestions").style.display = 'block';
			visible = true;	
		}

		var xmlhttp = new XMLHttpRequest();
		var url = "test.json";
		var selected, search_old, visible;

		xmlhttp.onreadystatechange = function() {
			var q = $("search").value.trim();

			if (q.length && this.readyState == 4 && this.status == 200) {
				var data = JSON.parse(this.responseText);
				var $suggestions = $("suggestions");

				// remove all items from list
				while ($suggestions.firstChild) {
					$suggestions.removeChild($suggestions.firstChild);
				}

				// escape special characters (anything non-alphanumeric + space)
				q = q.replace(/([^a-z0-9_ ])/gi, '\\$1');

				// new regexp object, fetch search criteria from search box
				const regex = new RegExp("(" + q + ")", 'gi');
				data.forEach(item => {
					if (regex.test(item.name)) {
						var $li = document.createElement("li");
						$li.innerHTML = item.name.replace(regex, '<b>$1</b>');
						$suggestions.appendChild($li);
					}
				});

				// show only if list of suggestions isn't empty
				if ($suggestions.firstChild) show();
			}
		};
		
	</script>
</head>
<body>
	<div id="huba">
		<form>
			<input type="text" id="search" autocomplete="off" autofocus>
			<ul id="suggestions"></ul>
		</form>
	</div>
	<script type="text/javascript">
		$("suggestions").style.width = $("search").offsetWidth + 'px';
		$("search").addEventListener('input', e => {
			search_old = null; // reset
			selected = null;
			visible = false;

			if ($("search").value !== '') {
				xmlhttp.open("GET", url + '?' + Date.now().toString(), true);
				xmlhttp.send();
			}
			else hide();
		});
		$("search").addEventListener('blur', e => {
			hide();
		});
		$("search").addEventListener('keydown', e => {
			if (!visible) return;

			// cute little trick! ~[a,b].indexOf(c) returns 'not 0' if c is not in [a,b]
			// why? cuz 0 = 00000000000000000000000000000000
			// and flipping the bits (~) yields 11111111111111111111111111111111
			// whis is -1 in decimal
			// and vice versa. so if index = -1, ~ -1 = 0 is returned
			// if index !== -1, a nonzero integer is returned
			if (~[key.up, key.down].indexOf(e.keyCode)) {
				e.preventDefault();

				switch (e.keyCode) {
					case key.down:
					if (selected) {
						selected.classList.remove('selected');
						selected = selected.nextSibling;
					}
					else selected = $("suggestions").firstChild;
					break;

					case key.up:
					if (selected) {
						selected.classList.remove('selected');
						selected = selected.previousSibling;
					}
					else selected = $("suggestions").lastChild;
				}

				if (selected) selected.classList.add('selected');

				// store old value
				search_old = search_old || $("search").value;
				$("search").value = (selected) ? selected.textContent : search_old;
			}
			else if (e.keyCode === key.esc) { // ESC key
				if (selected) $("search").value = search_old;
				hide();
			}
		});

		$("suggestions").addEventListener('mousedown', e => {
			$("search").value = e.target.textContent;
			e.preventDefault(); // prevents the blur event from firing

			hide();
		});
	</script>
</body>
</html>