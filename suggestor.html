
<!--
	should abort already running xmlhttprequest when typing along
	should cache the result (key in cache is the search value)
	should have zero delay
	should present suggestions as an unordered list
	should reuse the xmlhttprequest object and abort the previous one, if any
	should create the suggestions element dynamically
	should insert UL element dynamically, just after the text field
	should use DOM operations instead of innerHTML when updating
	should show suggestions in a box with a max-height, overflow will cause scrollbar
	should handle key down and key up accordingly (scroll selected item into view)

	should be OO
	should accept a function which retrives data and returns a filtered array of search result

	TODO:
-->

<!DOCTYPE html>
<html>
<head>
	<title>box</title>
	<link rel="stylesheet" type="text/css" href="suggestor.css">
	<script type="text/javascript">
		const key = {
			up: 38,
			down: 40,
			esc: 27
		}

		function $(id) {
			return document.getElementById(id);
		}

		function hide() {
			$("suggestions").style.display = 'none';
			visible = false;
		}

		function show() {
			$("suggestions").style.display = 'block';
			visible = true;	
		}

		var xmlhttp = new XMLHttpRequest();
		var url = "test.json";
		var selected, search_old, visible;

		xmlhttp.onreadystatechange = function() {
			// console.log(this.readyState, this.status);
			if (this.readyState == 4 && this.status == 200) {
				var data = JSON.parse(this.responseText);

				var $suggestions = $("suggestions");

				// remove all items from list
				while ($suggestions.firstChild) {
					$suggestions.removeChild($suggestions.firstChild);
				}
				

				// new regexp object, fetch search criteria from search box
				const regex = new RegExp("(" + $("search").value + ")", 'gi');
				data.forEach(item => {
					if (regex.test(item.name)) {
						var $li = document.createElement("li");
						$li.innerHTML = (item.name).replace(regex, '<b>$1</b>');

						$suggestions.appendChild($li);
					}
				});

				// show only if list of suggestions isn't empty
				if ($suggestions.firstChild) show();
			}
		};
		
	</script>
</head>
<body>
	<div id="huba">
		<form>
			<input type="text" id="search" autocomplete="off" autofocus>
			<ul id="suggestions"></ul>
		</form>
	</div>
	<script type="text/javascript">
		$("suggestions").style.width = $("search").offsetWidth + 'px';
		$("search").addEventListener('input', e => {
			search_old = null; // reset
			selected = null;
			visible = false;

			if ($("search").value !== '') {
				xmlhttp.open("GET", url, true);
				xmlhttp.send();
			}
			else hide();
		});
		$("search").addEventListener('blur', e => {
			hide();
		});
		$("search").addEventListener('keydown', e => {
			if (!visible) return;

			if (e.keyCode === key.up || e.keyCode === key.down) {
				e.preventDefault();

				switch (e.keyCode) {
					case key.down:
					if (selected) {
						selected.classList.remove('selected');
						selected = selected.nextSibling;
					}
					else selected = $("suggestions").firstChild;
					break;

					case key.up:
					if (selected) {
						selected.classList.remove('selected');
						selected = selected.previousSibling;
					}
					else selected = $("suggestions").lastChild;
				}

				if (selected) selected.classList.add('selected');

				// store old value
				search_old = search_old || $("search").value;
				$("search").value = (selected) ? selected.textContent : search_old;
			}
			else if (e.keyCode === key.esc) { // ESC key
				if (selected) $("search").value = search_old;
				hide();
			}
		});

		$("suggestions").addEventListener('mousedown', e => {
			$("search").value = e.target.textContent;
			e.preventDefault(); // prevents the blur event from firing

			hide();
		});
	</script>
</body>
</html>